// Generated by CoffeeScript 1.6.2
(function() {
  var Computer,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Computer = (function() {
    function Computer(board) {
      this.board = board;
    }

    Computer.prototype.readSpaces = function() {
      return this.board.spaces;
    };

    Computer.prototype.findBestMove = function() {
      if (this.checkForComputerWin() || this.checkForBlockPlayerWin() || this.checkForComputerDoubleThreat() || this.checkForPlayerDoubleThreat() || this.checkMiddleAvailability() || this.checkPlayerOppositeCorner() || this.getAnyCorner() || this.getAnyWall()) {
        return this.bestMove;
      }
    };

    Computer.prototype.checkForComputerWin = function() {
      return this.checkForPossibleWin(this.board.secondPlayerToken);
    };

    Computer.prototype.checkForBlockPlayerWin = function() {
      return this.checkForPossibleWin(this.board.firstPlayerToken);
    };

    Computer.prototype.checkForComputerDoubleThreat = function() {
      if (this.canGetCornerDoubleThreat()) {
        return true;
      }
      if (this.canGetWallDoubleThreat()) {
        return true;
      }
      return false;
    };

    Computer.prototype.checkForPlayerDoubleThreat = function() {
      if (this.checkCornerDoubleThreat(this.board.firstPlayerToken) || this.checkWallDoubleThreat(this.board.firstPlayerToken)) {
        return true;
      }
      return false;
    };

    Computer.prototype.checkMiddleAvailability = function() {
      return this.getEmpty([4]);
    };

    Computer.prototype.checkPlayerOppositeCorner = function() {
      return this.checkOppositeCorner(this.board.firstPlayerToken);
    };

    Computer.prototype.getAnyCorner = function() {
      return this.getEmpty(this.board.cornerSpots);
    };

    Computer.prototype.getAnyWall = function() {
      return this.getEmpty(this.board.wallSpots);
    };

    Computer.prototype.findEmpty = function(spaces) {
      return this.board.getSpaces(spaces, this.board.emptyToken);
    };

    Computer.prototype.getEmpty = function(spaces) {
      var availableSpaces;

      availableSpaces = this.findEmpty(spaces);
      if (availableSpaces.length > 0) {
        return this.getBestMove(availableSpaces);
      }
      return false;
    };

    Computer.prototype.canGetWallDoubleThreat = function() {
      if (this.checkWallDoubleThreat(this.board.secondPlayerToken)) {
        return true;
      }
      return false;
    };

    Computer.prototype.canGetCornerDoubleThreat = function() {
      var edge, _i, _len, _ref;

      if (this.checkCornerDoubleThreat(this.board.secondPlayerToken)) {
        _ref = this.allEdges;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          edge = _ref[_i];
          if (this.checkAllEmpty(edge)) {
            return this.getBestMove([edge[1]]);
          }
        }
      }
      return false;
    };

    Computer.prototype.checkAllEmpty = function(spots) {
      return this.checkSpots(spots, this.board.emptyToken);
    };

    Computer.prototype.checkOppositeCorner = function(token) {
      var filledSpaces;

      filledSpaces = this.board.getSpaces(this.board.cornerSpots, token);
      return this.checkIfOppositeAvailable(filledSpaces);
    };

    Computer.prototype.checkIfOppositeAvailable = function(spaces) {
      var emptySpaces, oppositeSpaces;

      oppositeSpaces = this.findOpposite(spaces);
      emptySpaces = this.findEmpty(oppositeSpaces);
      if (emptySpaces.length > 0) {
        return this.getBestMove(emptySpaces);
      }
      return false;
    };

    Computer.prototype.findOpposite = function(spaces) {
      var space, _i, _len, _results;

      _results = [];
      for (_i = 0, _len = spaces.length; _i < _len; _i++) {
        space = spaces[_i];
        _results.push(this.board.oppositeSpots[space]);
      }
      return _results;
    };

    Computer.prototype.checkWallDoubleThreat = function(token) {
      if (this.wallDoubleThreatPossible(token)) {
        return true;
      }
      return false;
    };

    Computer.prototype.wallDoubleThreatPossible = function(token) {
      var combos, _i, _len, _ref;

      _ref = this.wallCombos();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        combos = _ref[_i];
        if (this.occupyBothWalls(combos, token)) {
          return true;
        }
      }
    };

    Computer.prototype.occupyBothWalls = function(combos, token) {
      if (this.occupyWall(combos[0], token) && this.occupyWall(combos[1], token)) {
        return this.getBestMove(this.intersection(combos[0], combos[1]));
      }
      return false;
    };

    Computer.prototype.intersection = function(a, b) {
      var value, _i, _len, _results;

      _results = [];
      for (_i = 0, _len = a.length; _i < _len; _i++) {
        value = a[_i];
        if (__indexOf.call(b, value) >= 0) {
          _results.push(value);
        }
      }
      return _results;
    };

    Computer.prototype.occupyWall = function(combo, token) {
      return this.checkSpot(combo[1], token) && this.findEmpty(combo).length === 2;
    };

    Computer.prototype.checkCornerDoubleThreat = function(token) {
      if (this.cornerDoubleThreatPossible(token)) {
        return this.getBestMove(this.board.wallSpots);
      }
      return false;
    };

    Computer.prototype.cornerDoubleThreatPossible = function(token) {
      if ((this.firstCornersOccupied(token) && this.firstEdgesEmpty()) || (this.secondCornerOccupied(token) && this.secondEdgesEmpty())) {
        return true;
      }
      return false;
    };

    Computer.prototype.firstCornersOccupied = function(token) {
      return this.checkSpots([0, 8], token);
    };

    Computer.prototype.secondCornerOccupied = function(token) {
      return this.checkSpots([2, 6], token);
    };

    Computer.prototype.firstEdgesEmpty = function() {
      return this.checkEdgesEmpty([this.allEdges[3], this.allEdges[4]]);
    };

    Computer.prototype.secondEdgesEmpty = function() {
      return this.checkEdgesEmpty([this.allEdges[1], this.allEdges[2]]);
    };

    Computer.prototype.checkEdgesEmpty = function(edges) {
      var edge, _i, _len;

      for (_i = 0, _len = edges.length; _i < _len; _i++) {
        edge = edges[_i];
        if (this.getEmpty(edge)) {
          return true;
        }
      }
      return false;
    };

    Computer.prototype.checkSpots = function(locations, token) {
      var spot, _i, _len;

      for (_i = 0, _len = locations.length; _i < _len; _i++) {
        spot = locations[_i];
        if (!this.checkSpot(spot, token)) {
          return false;
        }
      }
      return true;
    };

    Computer.prototype.checkSpot = function(spot, token) {
      return this.board.checkSpot(spot, token);
    };

    Computer.prototype.checkForPossibleWin = function(token) {
      var combo, winCombos, _i, _j, _len, _len1, _ref;

      _ref = [this.board.rows, this.board.columns, this.board.diagonals];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        winCombos = _ref[_i];
        for (_j = 0, _len1 = winCombos.length; _j < _len1; _j++) {
          combo = winCombos[_j];
          if (this.winIsPossible(combo, token)) {
            return true;
          }
        }
      }
      return false;
    };

    Computer.prototype.winIsPossible = function(combo, token) {
      if (this.twoInARow(combo, token) && this.isWinnable(combo)) {
        return this.getBestMove(combo);
      }
      return false;
    };

    Computer.prototype.getBestMove = function(combo) {
      this.bestMove = this.findEmpty(combo)[0];
      return true;
    };

    Computer.prototype.twoInARow = function(combo, token) {
      return this.findAll(combo, token).length === 2;
    };

    Computer.prototype.findAll = function(combo, token) {
      return this.board.getSpaces(combo, token);
    };

    Computer.prototype.isWinnable = function(combo) {
      return this.findEmpty(combo).length === 1;
    };

    Computer.prototype.allEdges = [[1, 0, 3], [5, 8, 7], [1, 2, 5], [3, 6, 7]];

    Computer.prototype.wallCombos = function() {
      return [[this.board.rows[0], this.board.columns[0]], [this.board.rows[0], this.board.columns[2]], [this.board.rows[2], this.board.columns[0]], [this.board.rows[2], this.board.columns[2]]];
    };

    return Computer;

  })();

  window.Computer = Computer;

}).call(this);
