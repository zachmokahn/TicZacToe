// Generated by CoffeeScript 1.6.2
(function() {
  describe("Computer", function() {
    var ai, emptyBoard, fullBoard;

    fullBoard = emptyBoard = ai = void 0;
    beforeEach(function() {
      emptyBoard = [" ", " ", " ", " ", " ", " ", " ", " ", " "];
      fullBoard = ["X", "X", "X", "X", "X", "X", "X", "X", "X"];
      return ai = new Computer("O", "X");
    });
    return describe("Methods", function() {
      describe("WallLocation", function() {
        beforeEach(function() {
          spyOn(ai, 'winningLocation').andReturn(null);
          spyOn(ai, 'blockLocation').andReturn(null);
          spyOn(ai, 'blockDoubleThreatLocation').andReturn(null);
          spyOn(ai, 'playCenterLocation').andReturn(null);
          spyOn(ai, 'playOppositeCornerLocation').andReturn(null);
          return spyOn(ai, 'playAnyCornerLocation').andReturn(null);
        });
        it("should return an array of all the wall spots if the board is empty", function() {
          return expect(ai.gameLogic(emptyBoard)).toEqual([1, 3, 5, 7]);
        });
        return it("should return an array of approriate characters", function() {
          emptyBoard[1] = "X";
          expect(ai.gameLogic(emptyBoard)).toEqual([3, 5, 7]);
          emptyBoard[7] = "X";
          return expect(ai.gameLogic(emptyBoard)).toEqual([3, 5]);
        });
      });
      describe("CornerLocation", function() {
        beforeEach(function() {
          spyOn(ai, 'winningLocation').andReturn(null);
          spyOn(ai, 'blockLocation').andReturn(null);
          spyOn(ai, 'blockDoubleThreatLocation').andReturn(null);
          spyOn(ai, 'playCenterLocation').andReturn(null);
          return spyOn(ai, 'playOppositeCornerLocation').andReturn(null);
        });
        it("should return an array of all the corner spots if the board is empty", function() {
          return expect(ai.gameLogic(emptyBoard)).toEqual([0, 2, 6, 8]);
        });
        return it(" should return an array of approriate characters", function() {
          emptyBoard[0] = "X";
          expect(ai.gameLogic(emptyBoard)).toEqual([2, 6, 8]);
          emptyBoard[8] = "X";
          return expect(ai.gameLogic(emptyBoard)).toEqual([2, 6]);
        });
      });
      describe("OppositeCornerLocation", function() {
        beforeEach(function() {
          spyOn(ai, 'winningLocation').andReturn(null);
          spyOn(ai, 'blockLocation').andReturn(null);
          spyOn(ai, 'blockDoubleThreatLocation').andReturn(null);
          return spyOn(ai, 'playCenterLocation').andReturn(null);
        });
        it("should return [0] if [8] is occupied", function() {
          emptyBoard[8] = "X";
          return expect(ai.gameLogic(emptyBoard)).toEqual([0]);
        });
        return it("should return [2] if [6] is occupied", function() {
          emptyBoard[6] = "X";
          return expect(ai.gameLogic(emptyBoard)).toEqual([2]);
        });
      });
      describe("CenterLocation", function() {
        beforeEach(function() {
          spyOn(ai, 'winningLocation').andReturn(null);
          spyOn(ai, 'blockLocation').andReturn(null);
          return spyOn(ai, 'blockDoubleThreatLocation').andReturn(null);
        });
        return it("should return [4] if center is unoccupied", function() {
          return expect(ai.gameLogic(emptyBoard)).toEqual([4]);
        });
      });
      describe("blockDoubleThreat", function() {
        beforeEach(function() {
          spyOn(ai, 'winningLocation').andReturn(null);
          return spyOn(ai, 'blockLocation').andReturn(null);
        });
        it("should return [8] if [5,7] are occupied by player and [2,6] are open", function() {
          emptyBoard[5] = "X";
          emptyBoard[4] = "O";
          emptyBoard[7] = "X";
          console.log("start");
          expect(ai.gameLogic(emptyBoard)).toEqual([8]);
          return console.log("end");
        });
        return it("should return [1,3,5,7] if [2,6] are occupied by the player", function() {
          emptyBoard[2] = "X";
          emptyBoard[6] = "X";
          return expect(ai.gameLogic(emptyBoard)).toEqual([1, 3, 5, 7]);
        });
      });
      describe("Check For Wins", function() {
        describe("Check Horizontal Win", function() {
          it("should return [2] if [0,1] are occupied", function() {
            emptyBoard[0] = "X";
            emptyBoard[1] = "X";
            ai.board = emptyBoard;
            return expect(ai.check("X", ai.rows)).toEqual([2]);
          });
          it("should return [0] if [1,2] are occupied", function() {
            emptyBoard[1] = "X";
            emptyBoard[2] = "X";
            ai.board = emptyBoard;
            return expect(ai.check("X", ai.rows)).toEqual([0]);
          });
          it("should return [4] if [3,5] are occupied", function() {
            emptyBoard[3] = "X";
            emptyBoard[5] = "X";
            ai.board = emptyBoard;
            return expect(ai.check("X", ai.rows)).toEqual([4]);
          });
          return it("should return undefined if [6,7,8] are occupied", function() {
            emptyBoard[6] = "X";
            emptyBoard[7] = "X";
            emptyBoard[8] = "O";
            ai.board = emptyBoard;
            return expect(ai.check("X", ai.rows)).toEqual(null);
          });
        });
        describe("Check Vertical Win", function() {
          it("should return [4] if [1,7] are occupied", function() {
            emptyBoard[1] = "X";
            emptyBoard[7] = "X";
            ai.board = emptyBoard;
            return expect(ai.check("X", ai.columns)).toEqual([4]);
          });
          it("should return [1] if [4,7] are occupied", function() {
            emptyBoard[4] = "X";
            emptyBoard[7] = "X";
            ai.board = emptyBoard;
            return expect(ai.check("X", ai.columns)).toEqual([1]);
          });
          it("should return [8] if [2,5] are occupied", function() {
            emptyBoard[2] = "X";
            emptyBoard[5] = "X";
            ai.board = emptyBoard;
            return expect(ai.check("X", ai.columns)).toEqual([8]);
          });
          return it("should return undefined if [0,3,6] are occupied", function() {
            emptyBoard[0] = "X";
            emptyBoard[3] = "X";
            emptyBoard[6] = "O";
            ai.board = emptyBoard;
            return expect(ai.check("X", ai.columns)).toEqual(null);
          });
        });
        return describe("Check Diagonal Win", function() {
          it("should return [4] if [0,8] are occupied", function() {
            emptyBoard[0] = "X";
            emptyBoard[8] = "X";
            ai.board = emptyBoard;
            return expect(ai.check("X", ai.diagonals)).toEqual([4]);
          });
          it("should return [2] if [4,6] are occupied", function() {
            emptyBoard[4] = "X";
            emptyBoard[6] = "X";
            ai.board = emptyBoard;
            return expect(ai.check("X", ai.diagonals)).toEqual([2]);
          });
          return it("should return undefined if [0,4,8] are occupied", function() {
            emptyBoard[0] = "X";
            emptyBoard[4] = "X";
            emptyBoard[8] = "O";
            ai.board = emptyBoard;
            return expect(ai.check("X", ai.diagonals)).toEqual(null);
          });
        });
      });
      return describe("blockLocation", function() {
        beforeEach(function() {
          return spyOn(ai, 'winningLocation').andReturn(null);
        });
        it("HORIZONTAL CHECK: it should return [1] if [0,2] are occupied by opponent", function() {
          emptyBoard[0] = "X";
          emptyBoard[2] = "X";
          return expect(ai.gameLogic(emptyBoard)).toEqual([1]);
        });
        it("VERTICAL CHECK: it should return [7] if [1,4] are occupied by opponent", function() {
          emptyBoard[1] = "X";
          emptyBoard[4] = "X";
          return expect(ai.gameLogic(emptyBoard)).toEqual([7]);
        });
        return it("DIAGONAL CHECK: it should return [0] if [4,8] are occupied by opponent", function() {
          emptyBoard[4] = "X";
          emptyBoard[8] = "X";
          return expect(ai.gameLogic(emptyBoard)).toEqual([0]);
        });
      });
    });
  });

}).call(this);
