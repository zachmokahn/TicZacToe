// Generated by CoffeeScript 1.6.2
(function() {
  describe("Computer", function() {
    var board, computer, modifiedBoard;

    modifiedBoard = board = computer = void 0;
    beforeEach(function() {
      modifiedBoard = [" ", " ", " ", " ", " ", " ", " ", " ", " "];
      board = new Board("X", "O");
      return computer = new Computer(board);
    });
    describe("new Computer", function() {
      it("should take a Board in the parameters", function() {
        return expect(computer.board).toEqual(board);
      });
      return it("should detect the spaces in the board", function() {
        return expect(computer.readSpaces()).toEqual(modifiedBoard);
      });
    });
    describe("Methods", function() {
      describe("checkForComputerWin", function() {
        it("should return true and assign bestMove to the winning move", function() {
          modifiedBoard[0] = "O";
          modifiedBoard[1] = "O";
          board.spaces = modifiedBoard;
          expect(computer.checkForComputerWin()).toEqual(true);
          return expect(computer.bestMove).toEqual(2);
        });
        return it("should return false and not assign bestMove if win is not present", function() {
          modifiedBoard[0] = "O";
          modifiedBoard[1] = "X";
          board.spaces = modifiedBoard;
          expect(computer.checkForComputerWin()).toEqual(false);
          return expect(computer.bestMove).not.toBeDefined();
        });
      });
      describe("checkForBlockPlayerWin", function() {
        it("should return true and assign bestMove to the blocking move", function() {
          modifiedBoard[0] = "X";
          modifiedBoard[1] = "X";
          board.spaces = modifiedBoard;
          expect(computer.checkForBlockPlayerWin()).toEqual(true);
          return expect(computer.bestMove).toEqual(2);
        });
        return it("should return false and not assign bestMove if block is not present", function() {
          modifiedBoard[0] = "O";
          modifiedBoard[1] = "X";
          board.spaces = modifiedBoard;
          expect(computer.checkForBlockPlayerWin()).toEqual(false);
          return expect(computer.bestMove).not.toBeDefined();
        });
      });
      describe("checkForPlayerDoubleThreat", function() {
        describe("checkCornerDoubleThreat", function() {
          it("should return true and assign bestMove to a doubleThreat deterent if [0,8] filled", function() {
            modifiedBoard[0] = "X";
            modifiedBoard[4] = "O";
            modifiedBoard[8] = "X";
            board.spaces = modifiedBoard;
            expect(computer.checkForPlayerDoubleThreat()).toEqual(true);
            return expect(computer.bestMove).toEqual(1);
          });
          it("should return true and assign bestMove to a doubleThreat deterent if [2,6] filled", function() {
            modifiedBoard[2] = "X";
            modifiedBoard[4] = "O";
            modifiedBoard[6] = "X";
            board.spaces = modifiedBoard;
            expect(computer.checkForPlayerDoubleThreat()).toEqual(true);
            return expect(computer.bestMove).toEqual(1);
          });
          return it("should return false and not assign bestMove if cornerDoubleThreat is not present", function() {
            board.spaces = modifiedBoard;
            expect(computer.checkForPlayerDoubleThreat()).toEqual(false);
            return expect(computer.bestMove).not.toBeDefined();
          });
        });
        return describe("checkWallDoubleThreat", function() {
          it("should return true and assign bestMove to a doubleThreat deterent if [5,7] filled", function() {
            modifiedBoard[5] = "X";
            modifiedBoard[4] = "O";
            modifiedBoard[7] = "X";
            board.spaces = modifiedBoard;
            expect(computer.checkForPlayerDoubleThreat()).toEqual(true);
            return expect(computer.bestMove).toEqual(8);
          });
          it("should return true and assign bestMove to a doubleThreat deterent if [3,7] filled", function() {
            modifiedBoard[3] = "X";
            modifiedBoard[4] = "O";
            modifiedBoard[7] = "X";
            board.spaces = modifiedBoard;
            expect(computer.checkForPlayerDoubleThreat()).toEqual(true);
            return expect(computer.bestMove).toEqual(6);
          });
          return it("should return false and not assign bestMove if a wallDoubleThreat is not present", function() {
            board.spaces = modifiedBoard;
            expect(computer.checkForPlayerDoubleThreat()).toEqual(false);
            return expect(computer.bestMove).not.toBeDefined();
          });
        });
      });
      describe("checkMiddleAvailability", function() {
        it("should return true and assign bestMove to the middle if space [4] is available", function() {
          board.spaces = modifiedBoard;
          expect(computer.checkMiddleAvailability()).toEqual(true);
          return expect(computer.bestMove).toEqual(4);
        });
        return it("should return false and not assign besetMove if the middle is not available", function() {
          modifiedBoard[4] = "X";
          board.spaces = modifiedBoard;
          expect(computer.checkMiddleAvailability()).toEqual(false);
          return expect(computer.bestMove).not.toBeDefined();
        });
      });
      describe("checkOppositeCorner", function() {
        it("should return true and assign bestMove to the opposite corner if available", function() {
          modifiedBoard[0] = "X";
          modifiedBoard[4] = "O";
          modifiedBoard[5] = "X";
          board.spaces = modifiedBoard;
          expect(computer.checkPlayerOppositeCorner()).toEqual(true);
          return expect(computer.bestMove).toEqual(8);
        });
        it("should return false and not assign bestMove if both corners are occupied", function() {
          modifiedBoard[0] = "X";
          modifiedBoard[8] = "O";
          board.spaces = modifiedBoard;
          expect(computer.checkPlayerOppositeCorner()).toEqual(false);
          return expect(computer.bestMove).not.toBeDefined();
        });
        return it("should return false and not assign bestMove if no corners are occupied", function() {
          board.spaces = modifiedBoard;
          expect(computer.checkPlayerOppositeCorner()).toEqual(false);
          return expect(computer.bestMove).not.toBeDefined();
        });
      });
      describe("getAnyCorner", function() {
        it("should return true and assign bestMove to any corner if availaible", function() {
          board.spaces = modifiedBoard;
          expect(computer.getAnyCorner()).toEqual(true);
          return expect(computer.bestMove).toEqual(0);
        });
        return it("should return false and not assign bestMove if no corner is available", function() {
          modifiedBoard[0] = "X";
          modifiedBoard[6] = "X";
          modifiedBoard[2] = "O";
          modifiedBoard[8] = "O";
          board.spaces = modifiedBoard;
          expect(computer.getAnyCorner()).toEqual(false);
          return expect(computer.bestMove).not.toBeDefined();
        });
      });
      return describe("getAnyWall", function() {
        it("should return true and assign bestMove to any wall spot if available", function() {
          board.spaces = modifiedBoard;
          expect(computer.getAnyWall()).toEqual(true);
          return expect(computer.bestMove).toEqual(1);
        });
        return it("should return false and not assign bestMove if no wall is available", function() {
          modifiedBoard[1] = "X";
          modifiedBoard[3] = "X";
          modifiedBoard[5] = "O";
          modifiedBoard[7] = "O";
          board.spaces = modifiedBoard;
          expect(computer.getAnyWall()).toEqual(false);
          return expect(computer.bestMove).not.toBeDefined();
        });
      });
    });
    return describe("findBestMove", function() {
      it("should take the winning move if present", function() {
        computer.board.spaces[0] = "X";
        computer.board.spaces[1] = "O";
        computer.board.spaces[2] = "X";
        computer.board.spaces[4] = "O";
        computer.board.spaces[3] = "X";
        return expect(computer.findBestMove()).toEqual(7);
      });
      it("should take the blocking move if present and can't win", function() {
        computer.board.spaces[0] = "X";
        computer.board.spaces[4] = "O";
        computer.board.spaces[3] = "X";
        return expect(computer.findBestMove()).toEqual(6);
      });
      it("should take a wall if corner double threat is present and no block is available", function() {
        computer.board.spaces[0] = "X";
        computer.board.spaces[4] = "O";
        computer.board.spaces[8] = "X";
        return expect(computer.findBestMove()).toEqual(1);
      });
      it("should take the blocking corner if a wall double threat present and no block is available", function() {
        computer.board.spaces[5] = "X";
        computer.board.spaces[4] = "O";
        computer.board.spaces[7] = "X";
        return expect(computer.findBestMove()).toEqual(8);
      });
      it("should take the center if no double threat present", function() {
        return expect(computer.findBestMove()).toEqual(4);
      });
      it("should take an opposite corner if no center is available", function() {
        computer.board.spaces[0] = "X";
        computer.board.spaces[4] = "O";
        computer.board.spaces[5] = "X";
        return expect(computer.findBestMove()).toEqual(8);
      });
      it("should play any corner if no opposite corner is available", function() {
        computer.board.spaces[3] = "X";
        computer.board.spaces[4] = "O";
        computer.board.spaces[5] = "X";
        return expect(computer.findBestMove()).toEqual(0);
      });
      return it("should play any wall if it no corner is available", function() {
        computer.board.spaces[4] = "X";
        computer.board.spaces[0] = "O";
        computer.board.spaces[8] = "X";
        computer.board.spaces[6] = "O";
        computer.board.spaces[2] = "X";
        computer.board.spaces[5] = "O";
        computer.board.spaces[3] = "X";
        return expect(computer.findBestMove()).toEqual(1);
      });
    });
  });

}).call(this);
